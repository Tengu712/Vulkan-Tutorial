---
marp: true
paginate: true
size: 16:9
style: |
  section {
    justify-content: normal;
  }
  section.top h1 {
    font-size: 2em;
    margin: 0px;
  }
  section.top h2 {
    margin: 0px;
  }
  section.top {
    text-align: center;
    justify-content: center;
  }
  section.section h1 {
    position: absolute;
    top: 450px;
    font-size: 2em;
  }
  strong {
    color: red;
  }
  img[alt~="center"] {
    display: block;
    margin: 1em auto;
  }
---

<!-- _class: top -->
# Simplest Vulkan Tutorial

## 天狗(Tengu712)

---

<!-- _class: section -->
# はじめに

---

# コンセプト

**網羅率を代償に、正しさを持って、簡単に速習すること。**

他のチュートリアルでは軽視されがちな「理論」の部分に重点を置く。
読みやすく、わかりやすく、試しやすい、を意識している。

当スライドを見てもプログラムは組めない。
当スライドを見て、プログラムを俯瞰できるようにしてほしい。

---

# 想定の対象者層

次の程度のリテラシーは欲しい：

* C言語が読める
* 行列の積が分かる
* コンピュータアーキテクチャが少し分かる

---

# サンプルコード

本スライドには断片的にしか掲載しない。適宜以下のリンクを参照してほしい。
https://github.com/Tengu712/Vulkan-Tutorial

尚、**独特**なコーディング規則について、以下のよう：

* 列数に上限なし
* ifの分岐後命令が一つなら中括弧なし
* ifの分岐後命令が一つかつbreak、continue、returnなら改行
* 構造体の実体は初期化子で初期化
* 初期化子内は余程短くない限り改行
* 必要以上に関数・モジュール分割しない

---

# 参考文献

どのくらい参考したかはともかく、ぼくがVulkanを勉強する上で参考にした公式文献を除く文献：

* すらりん『Vulkan Programming Vol.1』
* Fadis『3DグラフィクスAPI Vulkanを出来るだけやさしく解説する本』
* きてらい「やっていくVulkan入門」
* Alexander Overvoorde「VulkanTutorial」
* vblanco20-1「VulkanGuide」

局所的には、各頁に示す。

---

# RenderDoc

グラフィックプログラミングをしていると、
「コンパイルエラーもランタイムエラーもないが映らない」
なんてことがしょっちゅうある。

RenderDocを使うと以下を確認できたりするため、利用すべき：

* カラーバッファやデプスバッファ
* 各ステートの設定
* 各シェーダの入力と出力
* デプステストの結果

https://renderdoc.org/

---

<!-- _class: section -->
# Vulkan概要

---

# Vulkanとは

**グラフィックスAPI**の一種。
OpenGLの後継。従来のAPIより低水準で自由。

![center width:600](https://upload.wikimedia.org/wikipedia/commons/f/fe/Vulkan_logo.svg)

![center width:600](https://upload.wikimedia.org/wikipedia/commons/0/0b/Khronos_Group_logo.svg)

---

# グラフィックスAPIとは

主に**レンダリング**を目的とした、GPUを扱うための**API**。

「なぜAPIを介すのか？」
GPUのアーキテクチャは非公開であることが多く、アセンブリを書くのが現実的でないから。

「なぜGPUを使うのか？」
現状の並列計算力を比較してCPUよりGPUの方がレンダリング処理に強いから

---

# レンダリングとは

画面に図形を描画すること。手法は色々考えられる。

主要グラフィックスAPIでは、一つの対象に対してパイプライン処理を行う。
**レンダリングパイプライン**と言う。

---

# レンダリングパイプライン

描画対象を処理する工程。多くは大雑把に以下のよう：

1. インプットアセンブラ
2. ヴァーテックスシェーダ
3. ビューポート変換
4. ラスタライゼーション
5. フラグメントシェーダ
6. 合成

---

# Vulkanのレンダリングパイプライン

概ね右の通り。

参考元：
Khronos Group, Vulkan 1.1 Quick Reference

![bg right:65% height:95%](./img/vulkan-rendering-pipeline-diagram.svg)

---

# 今回扱う部分

![bg right:65% height:95%](./img/vulkan-rendering-pipeline-diagram-in-tutorial.svg)

---

# プログラマは何をすればいいか

**Vulkanに詳細な設定を与えて、Vulkanを介してGPUに計算させる。**

難しいアルゴリズムを考える必要は皆無。とにかく仕様と睨めっこ。

---

# イメージ図

---

<!-- _class: section -->
# GPUを扱うために

---

# GPUは遠隔リソース

普通GPUは、CPUと非同期に動作するデバイス。

またGPUは、PCI-Expressを介してメインメモリにアクセスできるが、
そのメモリ管理ユニットはCPUのものと異なる。

従って、**非同期処理が大前提**となる。

---

# キューとコマンド

GPUに計算をさせるためには、GPUのコマンドキューにコマンドを流す。

Vulkanにおいては、コマンドバッファにコマンドを積んでから、コマンドバッファごとキューに提出する。
コレクションの`push_all`メソッドみたいな。

提出されるなり、GPUは非同期に計算を始める。

---

# 同期の取り方

CPU-GPU間

* フェンスを用いる。
  コマンドバッファをキューに提出する際、フェンスを指定できる。
  提出したコマンドがすべて処理されるまで`vkWaitForFences`関数でCPUを休止できる。
* `vkDeviceWaitIdle`関数を用いる。
  プロセスから提出されたすべてコマンドが処理されるまでCPUを休止できる。

GPU-GPU間

* セマフォを用いる。
  GPU-GPU間で同期を取るべき処理各所で指定する。

---

# メモリの種類

メモリには少なくとも以下の二種類がある：

* メインメモリ(RAM)：CPUが扱うのに適したメモリ
* デバイスメモリ(VRAM)：GPUが扱うのに適した、CPUが扱えないメモリ

GPUからメインメモリ上のデータを扱うためには、
PCI-Expressを介すため、デバイスメモリ上のデータを扱うより遅い。

GPUしか扱わない・初期化後に更新しないデータは、デバイスメモリに格納するのが良い。

---

# デバイスメモリ

CPUはデバイスメモリを直接扱えないため、
CPUからデバイスメモリ上にデータを格納する場合は、以下の手順を踏む：

1. デバイスメモリを確保する
1. メインメモリにステージングバッファを確保する
1. ステージングバッファにデータを格納する
1. コピーコマンドを用いて、
   GPUにステージングバッファのデータをデバイスメモリへコピーしてもらう

---

<!-- _class: section -->
# 画面を一色にクリアする

---

# 描画の仕組み (不確定情報)

「フレームバッファ」とは、デバイスメモリ上に存在する描画表示領域。
`ディスプレイ幅xディスプレイ高xピクセルサイズ`のサイズの色情報配列。

ディスプレイのスキャンタイミングに合わせて「フレームバッファ」をディスプレイへ転送することで、ディスプレイに映像が表示される。

たぶん転送は、GPUによってCPUとは非同期的に行われる。

---

# 垂直同期 (不確定情報)

垂直同期とは、ディスプレイの走査線が右下から左上に戻るタイミング・つまり画面の更新が完了して次の更新が始まるまでのタイミングに合わせること。

「アプリケーションが垂直同期を取らずにプレゼンテーションを行う」ということは、ディスプレイへ転送中のフレームバッファに書き込みを行うということ。
